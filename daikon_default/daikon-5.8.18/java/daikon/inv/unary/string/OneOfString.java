// ***** This file is automatically generated from OneOf.java.jpp

package daikon.inv.unary.string;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.OneOf;

import java.io.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.*;

import java.util.Comparator;

  import java.util.regex.*;

import org.checkerframework.checker.initialization.qual.Initialized;
import org.checkerframework.checker.interning.qual.Interned;
import org.checkerframework.checker.lock.qual.GuardSatisfied;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.dataflow.qual.Pure;
import org.checkerframework.dataflow.qual.SideEffectFree;
import org.checkerframework.framework.qual.Unused;
import org.plumelib.reflection.Signatures;
import org.plumelib.util.ArraysPlume;
import org.plumelib.util.Intern;
import org.plumelib.util.StringsPlume;
import org.plumelib.util.UtilPlume;
import typequals.prototype.qual.NonPrototype;
import typequals.prototype.qual.Prototype;

// This subsumes an "exact" invariant that says the value is always exactly
// a specific value.  Do I want to make that a separate invariant
// nonetheless?  Probably not, as this will simplify implication and such.

  /**
   * Represents String variables that take on only a few distinct values. Prints as either
   * {@code x == c} (when there is only one value) or as {@code x one of {c1, c2, c3}}
   * (when there are multiple values).

   */

@SuppressWarnings("UnnecessaryParentheses")  // generated code, parentheses are sometimes needed
public final class OneOfString extends SingleString implements OneOf {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  /** Debugging logger. */
  public static final Logger debug =
    Logger.getLogger(OneOfString.class.getName());

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /** Boolean. True iff OneOf invariants should be considered. */
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

  /**
   * Positive integer. Specifies the maximum set size for this type of invariant (x is one of
   * {@code size} items).
   */

  public static int dkconfig_size = 3;

  // Probably needs to keep its own list of the values, and number of each seen.
  // (That depends on the slice; maybe not until the slice is cleared out.
  // But so few values is cheap, so this is quite fine for now and long-term.)

  @Unused(when=Prototype.class)
  private @Interned String[] elts;
  @Unused(when=Prototype.class)
  private int num_elts;

  @Prototype OneOfString() {
    super();
  }

  OneOfString(PptSlice slice) {
    super(slice);

    elts = new @Interned String[dkconfig_size];

    num_elts = 0;

  }

  private static @Prototype OneOfString proto = new @Prototype OneOfString();

  /** Returns the prototype invariant for OneOfString */
  public static @Prototype OneOfString get_proto() {
    return proto;
  }

  /** returns whether or not this invariant is enabled */
  @Override
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** instantiate an invariant on the specified slice */
  @Override
  public OneOfString instantiate_dyn(@Prototype OneOfString this, PptSlice slice) {
    return new OneOfString(slice);
  }

  @Pure
  public boolean is_boolean(@GuardSatisfied OneOfString this) {
    return var().file_rep_type.elementType() == ProglangType.BOOLEAN;
  }
  @Pure
  public boolean is_hashcode(@GuardSatisfied OneOfString this) {
    return var().file_rep_type.elementType() == ProglangType.HASHCODE;
  }

  @SideEffectFree
  @Override
  public OneOfString clone(@GuardSatisfied OneOfString this) {
    OneOfString result = (OneOfString) super.clone();
    result.elts = elts.clone();

    result.num_elts = this.num_elts;
    return result;
  }

  @Override
  public int num_elts() {
    return num_elts;
  }

  @Override
  public Object elt() {
    return elt(0);
  }

  public Object elt(int index) {
    if (num_elts <= index) {
      throw new Error("Represents " + num_elts + " elements, index " + index + " not valid");
    }

    return elts[index];
  }

  static Comparator<@Nullable String> comparator = Comparator.nullsFirst(Comparator.naturalOrder());

  private void sort_rep(@GuardSatisfied OneOfString this) {
    Arrays.sort(elts, 0, num_elts , comparator);
  }

  public @Interned String min_elt() {
    if (num_elts == 0) {
      throw new Error("Represents no elements");
    }
    sort_rep();
    return elts[0];
  }

  public @Interned String max_elt() {
    if (num_elts == 0) {
      throw new Error("Represents no elements");
    }
    sort_rep();
    return elts[num_elts - 1];
  }

  // Assumes the other array is already sorted
  public boolean compare_rep(int num_other_elts, @Interned String[] other_elts) {
    if (num_elts != num_other_elts) {
      return false;
    }
    sort_rep();
    for (int i = 0; i < num_elts; i++) {
      if (!((elts[i]) == (other_elts[i]))) { // elements are interned
        return false;
      }
    }
    return true;
  }

  private String subarray_rep(@GuardSatisfied OneOfString this) {
    // Not so efficient an implementation, but simple;
    // and how often will we need to print this anyway?
    sort_rep();
    StringBuilder sb = new StringBuilder();
    sb.append("{ ");
    for (int i = 0; i < num_elts; i++) {
      if (i != 0) {
        sb.append(", ");
      }

      if (PrintInvariants.dkconfig_static_const_infer) {
        boolean curVarMatch = false;
        PptTopLevel pptt = ppt.parent;
        for (VarInfo vi : pptt.var_infos) {
          if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
            Object constantVal = vi.constantValue();
            if (constantVal.equals(elts[i])) {
              sb.append(vi.name());
              curVarMatch = true;
            }
          }
        }

        if (curVarMatch == false) {
          sb.append(((elts[i] == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(elts[i]) + "\""));
        }
      } else {
        sb.append(((elts[i] == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(elts[i]) + "\""));
      }

    }
    sb.append(" }");
    return sb.toString();
  }

  @Override
  public String repr(@GuardSatisfied OneOfString this) {
    return "OneOfString" + varNames() + ": falsified=" + falsified
      + ", num_elts=" + num_elts
      + ", elts=" + subarray_rep();
  }

  public @Interned String[] getElts() {
    @Interned String[] temp = new @Interned String[elts.length];
    for (int i = 0; i < elts.length; i++) {
      temp[i] = elts[i];
    }
    return temp;
  }

  @SideEffectFree
  @Override
  public String format_using(@GuardSatisfied OneOfString this, OutputFormat format) {
    sort_rep();

    if (format.isJavaFamily()) {
      return format_java_family(format);
    }

    if (format == OutputFormat.DAIKON) {
      return format_daikon();
    } else if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    } else if (format == OutputFormat.ESCJAVA) {
      String result = format_esc();
      return result;
    } else if (format == OutputFormat.CSHARPCONTRACT) {
      return format_csharp_contract();
    } else {
      return format_unimplemented(format);
    }
  }

  public String format_daikon(@GuardSatisfied OneOfString this) {
    String varname = var().name();
    if (num_elts == 1) {

        boolean is_type = is_type();
        if (!is_type) {
          return varname + " == " + ((elts[0] == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(elts[0]) + "\"");
        } else {
          // It's a type
          String str = elts[0];
          if ((str == null) || "null".equals(str)) {
            return varname + " == null";
          } else {
            if (str.startsWith("[")) {
              str = Signatures.fieldDescriptorToBinaryName(str);
            }
            if (PrintInvariants.dkconfig_static_const_infer) {
              PptTopLevel pptt = ppt.parent;
              for (VarInfo vi : pptt.var_infos) {
                if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
                  Object constantVal = vi.constantValue();
                  if (constantVal.equals(str)) {
                    return varname + " == " + vi.name();
                  }
                }
              }
            }
            // ".class" (which is a suffix for a type name) and not
            // getClassSuffix (which is a suffix for an expression).
            return varname + " == " + str + ".class";
          }
        }

    } else {
      return varname + " one of " + subarray_rep();
    }
  }

  @Pure
  private boolean is_type(@GuardSatisfied OneOfString this) {
    return var().has_typeof();
  }

  private static Pattern dollar_char_pat = Pattern.compile("\\$([A-Za-z])");

  private static String format_esc_string2type(String str) {
    if ((str == null) || "null".equals(str)) {
      return "\\typeof(null)";
    }
    String type_str;
    if (str.startsWith("[")) {
      type_str = Signatures.fieldDescriptorToBinaryName(str);
    } else {
      type_str = str;
      if (type_str.startsWith("\"") && type_str.endsWith("\"")) {
        type_str = type_str.substring(1, type_str.length()-1);
      }
    }

    // Inner classes
    // type_str = type_str.replace('$', '.');
    // For named inner classes, convert "$" to ".".
    // For anonymous inner classes, leave as "$".
    Matcher m = dollar_char_pat.matcher(type_str);
    type_str = m.replaceAll(".$1");

    return "\\type(" + type_str + ")";
  }

  public String format_esc(@GuardSatisfied OneOfString this) {
    sort_rep();

    String varname = var().esc_name();

    String result;

    // We cannot say anything about Strings in ESC, just types (which
    // Daikon stores as Strings).
    if (!is_type()) {
      result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
    } else {
      // Format   \typeof(theArray) = "[Ljava.lang.Object;"
      //   as     \typeof(theArray) == \type(java.lang.Object[])
      // ... but still ...
      // format   \typeof(other) = "package.SomeClass;"
      //   as     \typeof(other) == \type(package.SomeClass)

      result = "";
      for (int i = 0; i < num_elts; i++) {
        if (i != 0) { result += " || "; }
        result += varname + " == " + format_esc_string2type(elts[i]);
      }
    }

    return result;
  }

public String format_csharp_contract(@GuardSatisfied OneOfString this) {

    @NonNull @Initialized String result;

  String varname = var().csharp_name();

    if (is_type()) {
        List<String> names = new ArrayList<>();
        for (int i = 0; i < num_elts; i++) {
             String str = elts[i];
             if ((str == null) || "null".equals(str)) {
                 names.add(varname + " == null");
             } else {
                 names.add(varname + " == typeof(" + str + ")");
             }
        }
        result = String.join(" || ", names);
    } else if (num_elts == 1) {
        String str = elts[0];
        result = (str == null || "null".equals(str))
               ? (varname + " == null")
               : (varname + ".Equals(" + ((str == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(str) + "\"") + ")");
    } else {
        List<String> names = new ArrayList<>();
        for (int i = 0; i < num_elts; i++) {
            String str = elts[i];
            names.add((str == null) ? "null" : ((str == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(str) + "\""));
        }
        result = varname + ".OneOf(" + String.join(", ", names) + ")";
    }

    return result;
  }

  public String format_java_family(@GuardSatisfied OneOfString this, OutputFormat format) {

    String result;

    // Setting up the name of the unary variable
    String varname = var().name_using(format);

    result = "";
    boolean is_type = is_type();
    for (int i = 0; i < num_elts; i++) {
      if (i != 0) { result += " || "; }
      String str = elts[i];
      if (!is_type) {
        result += varname + ".equals(" + ((str == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(str) + "\"") + ")";
      } else {
        // It's a type
        if ((str == null) || "null".equals(str)) {
          result += varname + " == null";
        } else {
          if (str.startsWith("[")) {
            str = Signatures.fieldDescriptorToBinaryName(str);
          }
          // ".class" (which is a suffix for a type name) and not
          // getClassSuffix (which is a suffix for an expression).
          // we need ".class.getName()" to make result a string
          result += varname + " == " + str + ".class.getName()";
        }
      }
    }

    return result;
  }

  public String format_simplify(@GuardSatisfied OneOfString this) {

    sort_rep();

    String varname =
      var().simplifyFixup(var().name_using(OutputFormat.SIMPLIFY));

    String result;

    result = "";
    boolean is_type = is_type();
    for (int i = 0; i < num_elts; i++) {
      String value = elts[i];
      if (is_type) {
        if (value == null) {
          // do nothing
        } else if (value.startsWith("[")) {
          value = Signatures.fieldDescriptorToBinaryName(value);
        } else if (value.startsWith("\"") && value.endsWith("\"")) {
          value = value.substring(1, value.length()-1);
        }
        value = "|T_" + value + "|";
      } else {
        value = simplify_format_string(value);
      }
      result += " (EQ " + varname + " " + value + ")";
    }
    if (num_elts > 1) {
      result = "(OR" + result + ")";
    } else if (num_elts == 1) {
      // chop leading space
      result = result.substring(1);
    } else if (num_elts == 0) {
      return format_too_few_samples(OutputFormat.SIMPLIFY, null);
    }

    if (result.indexOf("format_simplify") == -1) {
      daikon.simplify.SimpUtil.assert_well_formed(result);
    }
    return result;
  }

  @Override
  public InvariantStatus add_modified(@Interned String a, int count) {
    return runValue(a, count, true);
  }

  @Override
  public InvariantStatus check_modified(@Interned String a, int count) {
    return runValue(a, count, false);
  }

  private InvariantStatus runValue(@Interned String v, int count, boolean mutate) {
    InvariantStatus status;
    if (mutate) {
      status = add_mod_elem(v, count);
    } else {
      status = check_mod_elem(v, count);
    }
    if (status == InvariantStatus.FALSIFIED) {
      if (logOn() && mutate) {
        StringBuilder eltString = new StringBuilder();
        for (int i = 0; i < num_elts; i++) {
          eltString.append(((elts[i] == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(elts[i]) + "\"") + " ");
        }
        log("destroyed on sample %s previous vals = {%s} num_elts = %s",
             ((v == null) ? "null" : "\"" + StringsPlume.escapeNonASCII(v) + "\""), eltString, num_elts);
      }
      return InvariantStatus.FALSIFIED;
    }
    return status;
  }

  /**
   * Adds a single sample to the invariant. Returns
   * the appropriate InvariantStatus from the result
   * of adding the sample to this.
   */
  public InvariantStatus add_mod_elem(@Interned String v, int count) {
    InvariantStatus status = check_mod_elem(v, count);
    if (status == InvariantStatus.WEAKENED) {
      elts[num_elts] = v;
      num_elts++;
    }
    return status;
  }

  /**
   * Checks a single sample to the invariant. Returns
   * the appropriate InvariantStatus from the result
   * of adding the sample to this.
   */
  public InvariantStatus check_mod_elem(@Interned String v, int count) {

    // Look for v in our list of previously seen values.  If it's
    // found, we're all set.
    for (int i = 0; i < num_elts; i++) {
      // if (logDetail())
      //  log ("add_modified (" + v + ")");
      if (((elts[i]) == ( v))) {
        return InvariantStatus.NO_CHANGE;
      }
    }

    if (num_elts == dkconfig_size) {
      return InvariantStatus.FALSIFIED;
    }

    if (is_type() && (num_elts == 1)) {
      return InvariantStatus.FALSIFIED;
    }

    return InvariantStatus.WEAKENED;
  }

  @Override
  protected double computeConfidence() {
    // This is not ideal.
    if (num_elts == 0) {
      return Invariant.CONFIDENCE_UNJUSTIFIED;
    } else {
      return Invariant.CONFIDENCE_JUSTIFIED;
    }
  }

  @Pure
  @Override
  public @Nullable DiscardInfo isObviousStatically(VarInfo[] vis) {
    // Static constants are necessarily OneOf precisely one value.
    // This removes static constants from the output, which might not be
    // desirable if the user doesn't know their actual value.
    if (vis[0].isStaticConstant()) {
      assert num_elts <= 1;
      return new DiscardInfo(this, DiscardCode.obvious, vis[0].name() + " is a static constant.");
    }
    return super.isObviousStatically(vis);
  }

  /** {@inheritDoc} */
  @Override
  public @Nullable DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo v = vis[0];

    // We can check if all values in the list match with the ones we know about
    // (useful for booleans and numeric enumerations).
    if (v.aux.hasValue(VarInfoAux.VALID_VALUES)) {
      String[] vsValidValues         = v.aux.getList(VarInfoAux.VALID_VALUES);
      Set<@Interned String> setValidValues = new TreeSet<>();
      for (String s : vsValidValues) {
        setValidValues.add(s.intern());
      }
      Set<@Interned String> setValuesInvariant = new TreeSet<>();
      for (@Interned String e : elts) {
        if (e == null) {
  continue;
}
        setValuesInvariant.add(e);
      }

      if (setValidValues.equals(setValuesInvariant)) {
        return new DiscardInfo(this, DiscardCode.obvious,
          "The value list consists of all possible values");
      }
    }

    return null;
  }

  /**
   * Oneof can merge different formulas from lower points to create a single formula at an upper
   * point.
   */
  @Override
  public boolean mergeFormulasOk() {
    return true;
  }

  @Pure
  @Override
  public boolean isSameFormula(Invariant o) {
    OneOfString other = (OneOfString) o;
    if (num_elts != other.num_elts) {
      return false;
    }
    if (num_elts == 0 && other.num_elts == 0) {
      return true;
    }

    sort_rep();
    other.sort_rep();

    for (int i = 0; i < num_elts; i++) {
      if (!((elts[i]) == (other.elts[i]))) {
        return false;
      }
    }

    return true;
  }

  @Pure
  @Override
  public boolean isExclusiveFormula(Invariant o) {
    if (o instanceof OneOfString) {
      OneOfString other = (OneOfString) o;

      if (num_elts == 0 || other.num_elts == 0) {
        return false;
      }
      for (int i = 0; i < num_elts; i++) {
        for (int j = 0; j < other.num_elts; j++) {
          if (((elts[i]) == (other.elts[j]))) // elements are interned
            return false;
        }
      }

      return true;
    }

    return false;
  }

  @Override
  public boolean hasUninterestingConstant() {

    return false;
  }

  @Pure
  @Override
  public boolean isExact() {
    return num_elts == 1;
  }

  // Look up a previously instantiated invariant.
  public static @Nullable OneOfString find(PptSlice ppt) {
    assert ppt.arity() == 1;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof OneOfString) {
        return (OneOfString) inv;
      }
    }
    return null;
  }

  // Interning is lost when an object is serialized and deserialized.
  // Manually re-intern any interned fields upon deserialization.
  private void readObject(ObjectInputStream in) throws IOException,
    ClassNotFoundException {
    in.defaultReadObject();

    for (int i = 0; i < num_elts; i++) {
      elts[i] = Intern.intern(elts[i]);
    }
  }

  /**
   * Merge the invariants in invs to form a new invariant. Each must be a OneOfString invariant.
   * This code finds all of the oneof values from each of the invariants and returns the merged
   * invariant (if any).
   *
   * @param invs list of invariants to merge. The invariants must all be of the same type and should
   *     come from the children of parent_ppt. They should also all be permuted to match the
   *     variable order in parent_ppt.
   * @param parent_ppt slice that will contain the new invariant
   */
  @Override
  public @Nullable Invariant merge(List<Invariant> invs, PptSlice parent_ppt) {

    // Create the initial parent invariant from the first child
    OneOfString  first = (OneOfString) invs.get(0);
    OneOfString result = first.clone();
    result.ppt = parent_ppt;

    // Loop through the rest of the child invariants
    for (int i = 1; i < invs.size(); i++ ) {

      // Get this invariant
      OneOfString inv = (OneOfString) invs.get(i);

      // Loop through each distinct value found in this child and add
      // it to the parent.  If the invariant is falsified, there is no parent
      // invariant
      for (int j = 0; j < inv.num_elts; j++) {
        @Interned String val = inv.elts[j];

        InvariantStatus status = result.add_mod_elem(val, 1);
        if (status == InvariantStatus.FALSIFIED) {

          result.log("%s", "child value '" + val + "' destroyed oneof");

          return null;
        }
      }
    }

    result.log("Merged '%s' from %s child invariants", result.format(), invs.size());
    return result;
  }

  /**
   * Setup the invariant with the specified elements. Normally used when searching for a specified
   * OneOf. The elements of vals are not necessarily interned; this method interns each element.
   */
  public void set_one_of_val(String[] vals) {

    num_elts = vals.length;
    for (int i = 0; i < num_elts; i++) {
      elts[i] = Intern.intern(vals[i]);
    }
  }

  /**
   * Returns true if every element in this invariant is contained in the specified state. For
   * example if x = 1 and the state contains 1 and 2, true will be returned.
   */
  @Override
  public boolean state_match(Object state) {

    if (num_elts == 0) {
      return false;
    }

    if (!(state instanceof @Interned String[])) {
      // Daikon is about to crash.  Produce some debugging output.
      System.out.printf("state = %s [%s]%n", state, state.getClass());
      System.out.printf("problem with %s%n", this);
    }
    @Interned String[] e = (@Interned String[]) state;
    for (int i = 0; i < num_elts; i++) {
      boolean match = false;
      for (int j = 0; j < e.length; j++) {
        if (elts[i] == e[j]) {
          match = true;
          break;
        }
      }
      if (!match) {
        return false;
      }
    }
    return true;
  }

}
